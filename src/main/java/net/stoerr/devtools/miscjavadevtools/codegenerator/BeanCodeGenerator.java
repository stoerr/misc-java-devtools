package net.stoerr.devtools.miscjavadevtools.codegenerator;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.lang3.exception.ContextedRuntimeException;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.commons.lang3.tuple.Pair;

/**
 * Creates Java code that recreates a given Java Bean, or several.
 * @author Hans-Peter St√∂rr www.stoerr.net
 * @see ValueCodeGenerator
 */
public class BeanCodeGenerator {

    private final StringBuilder imports = new StringBuilder();
    private final StringBuilder code = new StringBuilder();
    private final Set<String> usedNames = new HashSet<>();
    /**
     * Maps the class and the hashcode of already coded beans to the actually used name. We naively assume that there
     * are no objects with the same hashcode.
     */
    private final Map<Pair<Class<Object>, Integer>, String> objectToNameMap = new HashMap<>();

    /**
     * Tries to create code to reproduce bean. If the bean is not a correct Java bean, it will silently return
     * incomplete code or it might fail.
     * @param bean Java Bean, not null
     * @param beanName the variable name for the bean, null if it should be autogenerated
     * @return the name of the bean in the {@link #getCode()}
     * @see #getImports()
     * @see #getCode()
     */
    public String makeBean(final Object bean, String beanName) {
        try {
            beanName = codeObject(bean, bean.getClass(), beanName);
        } catch (final RuntimeException e) {
            throw e;
        } catch (final Exception e) {
            throw new ContextedRuntimeException(e);
        }
        return beanName;
    }

    /** The required imports for the {@link #getCode()}. */
    public String getImports() {
        return imports.toString();
    }

    /** The collected code for everything. */
    public String getCode() {
        return code.toString();
    }

    @Override
    public String toString() {
        return getImports() + getCode();
    }

    private Pair<Class<Object>, Integer> objectKey(final Object bean) {
        final Class<Object> clazz = (Class<Object>) bean.getClass();
        return Pair.of(clazz, System.identityHashCode(bean));
    }

    /**
     * Generates code for recreating a Java Bean.
     * @param object the object for which we want to create code
     * @param type
     * @param preferredName if not null, we use this variable name for the object, else we autogenerate something
     * @return the actual code if object is creatable with a simple expression, or a variablename where the object is
     *         stored - preferredName if it is not null
     */
    private String codeObject(final Object object, Type type, final String preferredName)
            throws IllegalArgumentException, ReflectiveOperationException {
        if (!(object instanceof Collection) && !(object instanceof Map)) try {
            return ValueCodeGenerator.makeExpression(object, type, false);
        } catch (final IllegalArgumentException e) { // fall back to other
                // strategies.
            }

        if (null == type) type = object.getClass();
        appendImport(type);
        code.append("\n");

        final Pair<Class<Object>, Integer> key = objectKey(object);
        String beanName = objectToNameMap.get(key);
        if (null != beanName) if (null != preferredName && !preferredName.equals(beanName)) {
            code.append(importedJavaType(type)).append(" ").append(preferredName).append(" = ").append(beanName);
            objectToNameMap.put(key, beanName);
            return preferredName;
        } else return beanName;

        if (null != preferredName) beanName = preferredName;
        else {
            beanName = makeUniqueName(type);
            beanName = beanName.substring(0, 1).toLowerCase() + beanName.substring(1);
        }
        objectToNameMap.put(key, beanName);

        if (object instanceof List) codeList((List<?>) object, type, beanName);
        else if (object instanceof Map) codeMap((Map<?, ?>) object, type, beanName);
        else codeJavaBean(object, type, beanName);
        return beanName;
    }

    private String makeUniqueName(final Type type) {
        int i = 1;
        final String basename = TypeUtils.getRawType(type, type).getSimpleName();
        while (true) {
            final String name = basename + i;
            if (!usedNames.contains(name)) {
                usedNames.add(name);
                return name;
            }
            ++i;
        }
    }

    private void codeList(final List<?> list, final Type type, final String beanName)
            throws ReflectiveOperationException {
        codeNoargConstructor(list, type, beanName);
        for (final Object object : list)
            code.append(beanName).append(".add(").append(codeObject(object, null, null)).append(");\n");
    }

    private void codeMap(final Map<?, ?> map, final Type type, final String beanName)
            throws ReflectiveOperationException {
        codeNoargConstructor(map, type, beanName);
        for (final Entry<?, ?> entry : map.entrySet())
            code.append(beanName).append(".put(").append(codeObject(entry.getKey(), null, null)).append(", ").append(
                    codeObject(entry.getValue(), null, null)).append(");\n");
    }

    private void codeJavaBean(final Object bean, final Type type, final String beanName) throws IllegalAccessException,
            ReflectiveOperationException {
        codeNoargConstructor(bean, type, beanName);
        for (final Field field : FieldUtils.getAllFieldsList(bean.getClass())) {
            final String name = field.getName();
            final String upcaseName = name.substring(0, 1).toUpperCase() + name.substring(1);
            final Object value = FieldUtils.readField(field, bean, true);
            if (null == value) continue;
            final String valueCode = codeObject(value, field.getGenericType(), null);
            code.append(beanName).append(".set").append(upcaseName).append("(").append(valueCode).append(");\n");
        }
    }

    private void codeNoargConstructor(final Object bean, final Type type, final String beanName) {
        code.append(importedJavaType(type)).append(" ").append(beanName).append(" = new ").append(
                bean.getClass().getSimpleName()).append("();\n");
    }

    private void appendImport(final Type type) {
        final String name = TypeUtils.getRawType(type, type).getCanonicalName();
        if (name.startsWith("java.lang")) return;
        final String theimport = "import " + name + ";\n";
        if (0 > imports.indexOf(theimport)) imports.append(theimport);
    }

    /** Java source code form of type */
    private String importedJavaType(final Type type) {
        appendImport(type);
        final String sname = TypeUtils.getRawType(type, type).getSimpleName();
        if (type instanceof Class) return sname;
        else if (type instanceof ParameterizedType) {
            final ParameterizedType ptype = (ParameterizedType) type;
            final StringBuilder buf = new StringBuilder(sname).append("<");
            boolean first = true;
            for (final Type parmType : ptype.getActualTypeArguments()) {
                if (!first) buf.append(", ");
                first = false;
                buf.append(importedJavaType(parmType));
            }
            buf.append(">");
            return buf.toString();
        } else throw new IllegalArgumentException("Don't know how to handle " + type);
    }
}
